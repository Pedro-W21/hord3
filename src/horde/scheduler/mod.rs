use std::{collections::HashMap, fmt::{Debug, Display}, hash::Hash, thread};

use crossbeam::channel::{Receiver, Sender, unbounded};

/// This trait is meant to be implemented automatically on a type generated by the `task_derive` crate found in the Hord3 repository
pub trait HordeTaskHandler:Clone {

}

/// The HordeTask trait is the central trait used in the orchestrator/scheduler, which lets the developper specify the order of execution of any number of tasks
/// 
/// It is not meant to be implemented manually, instead, use the `task_derive` procedural macro crate, found in the same repository as Hord3
pub trait HordeTask: Hash + Eq + PartialEq  + Clone + Send + Sync + Debug {
    type HTH:HordeTaskHandler;
    type HTD:HordeTaskData<Self>;
    fn max_threads(&self) -> usize;
    fn data_from_handler(handler:&Self::HTH) -> Self::HTD;
}
 
/// HordeTaskData is meant to be automatically implemented on a type generated by the `task_derive` crate found in the Hord3 repository
pub trait HordeTaskData<HT:HordeTask>:Send + Sync {
    fn do_task(&mut self, task:HT, thread_number:usize, number_of_threads:usize);
}

/// The HordeTaskQueue represents a network of queued HordeTask sequences, as well as tasks that must be finished for the tick to end, allowing for some tasks to persist in between ticks (in theory, the functionality isn't implemented correctly to my knowledge)
#[derive(Clone)]
pub struct HordeTaskQueue<HT:HordeTask> {
    tasks:Vec<HordeTaskSequence<HT>>,
    must_be_finished_before_next:Vec<HT>
}

impl<HT:HordeTask> HordeTaskQueue<HT> {
    pub fn new(tasks:Vec<HordeTaskSequence<HT>>, must_be_finished_before_next:Vec<HT>) -> Self {
        Self { tasks, must_be_finished_before_next }
    }
}
#[derive(Clone, PartialEq, Eq)]
enum SequenceState {
    NotStarted,
    Started,
    Finished,
}

/// a HordeTaskSequence is a sequence of `SequencedTask`s that must be done sequentially as specified by the developper
/// task sequences are Clone to allow reusing them easily between game engine ticks, the sequences of actions to perform each tick are likely going to be consistent for a given game
/// 
/// Those sequences are also not checked in any way, it is possible to create deadlocks and other buggy behavior by creating impossible sequences.
#[derive(Clone)]
pub struct HordeTaskSequence<HT:HordeTask> {
    state:SequenceState,
    seq:Vec<SequencedTask<HT>>,
    position:usize,
}

impl<HT:HordeTask> HordeTaskSequence<HT> {
    pub fn new(seq:Vec<SequencedTask<HT>>) -> Self {
        Self { state: SequenceState::NotStarted, seq, position:0 }
    }
    fn current_task(&self) -> SequencedTask<HT> {
        self.seq[self.position].clone()
    }
    fn start_sequence(&mut self) {
        self.state = SequenceState::Started;
    }
    fn get_state(&self) -> SequenceState {
        self.state.clone()
    }
    fn advance_sequence(&mut self) {
        self.position += 1;
        if self.position >= self.seq.len() {
            self.state = SequenceState::Finished
        }
    }
}


/// The SequencedTask is the building block of a HordeTaskSequence, 
/// - StartTask(task) lets you try to start a given task on its maximum number of threads
/// - WaitFor(task) will block that sequence until the specified task is complete (all threads working on it have finished it)
/// - StartSequence(sequence_index) will start another sequence in the HordeTaskQueue that the HordeTaskSequence this SequencedTask is in is a part of
/// 
/// No tasks are automatically waited at the end of a tick, all tasks that must end should have a corresponding SequencedTask::WaitFor in an executed sequence in each tick
#[derive(Clone)]
pub enum SequencedTask<HT:HordeTask> {
    WaitFor(HT),
    StartSequence(usize),
    StartTask(HT)
}

/// HordeScheduler handles assigning tasks to work threads and applying HordeTaskQueues as they are passed to it, it should be reused between ticks, and given a new queue each time
pub struct HordeScheduler<HT:HordeTask> {
    handler:HT::HTH,
    current_tasks:HordeTaskQueue<HT>,
    task_counter:HashMap<HT, usize>,
    send:Sender<SchedulerTask<HT>>,
    rcv:Receiver<HT>,
    number_of_threads:usize,
    idle_threads:usize,
    tasks_in_flight:usize
}

pub enum SchedulerTask<HT:HordeTask> {
    Task{tsk:HT, thread_number:usize, number_of_threads_on_task:usize},
    Stop,
}

impl<HT:HordeTask + 'static> HordeScheduler<HT> {
    /// This creates a new scheduler, the number_of_threads here is the total thread budget given to it, the scheduler will only create and handle as many threads as that budget, and it currently cannot be changed post-creation
    pub fn new(initial_queue:HordeTaskQueue<HT>, handler:HT::HTH, number_of_threads:usize) -> Self {
        let task_counter = HashMap::new();
        let (send_task, receive_task) = unbounded();
        let (send_stop, recveive_stop) = unbounded();
        let mut out = Self {handler, task_counter, current_tasks:initial_queue, send:send_task, rcv:recveive_stop, number_of_threads, idle_threads:number_of_threads, tasks_in_flight:0};
        for i in 0..number_of_threads {
            let send_clone = send_stop.clone();
            let rcv_clone = receive_task.clone();
            let data = HT::data_from_handler(&out.handler);
            thread::spawn(move || {
                task_thread(rcv_clone, send_clone, data);
            });
        }
        out
    }

    /// this associated function sets a new queue up to be used in the next tick, it MUST be called before scheduler.tick() for anything to happen
    pub fn initialise(&mut self, new_queue:HordeTaskQueue<HT>) {
        self.current_tasks = new_queue;
        self.current_tasks.tasks[0].start_sequence();
    }

    /// Tick executes the queue that the scheduler currently has, and may block indefinitely if the queue is impossible to finish
    pub fn tick(&mut self) {
        let mut finished = false;
        while !finished {
            if !self.advance_all_sequences() && !self.receive_stop() {
                finished = true;
            }
        }
    }
    fn receive_stop(&mut self) -> bool {
        let mut anything_to_receive = false;
        for task in &self.current_tasks.must_be_finished_before_next {
            match self.task_counter.get(task) {
                Some(counter) => if *counter > 0 {anything_to_receive = true; break},
                None => (),
            }
        }
        if anything_to_receive {
            match self.rcv.recv() {
                Ok(stop) => match self.task_counter.get_mut(&stop) {
                    Some(counter) => {
                        *counter -= 1;
                        if self.current_tasks.must_be_finished_before_next.contains(&stop) && *counter == 0 {
                            self.current_tasks.must_be_finished_before_next.retain(|tsk| {*tsk != stop});
                            //dbg!(stop);
                        }
                        self.tasks_in_flight -= 1;
                    },
                    None => panic!("task end received before start... OH MY GOD !")
                },
                Err(error) => panic!("{}", error)
            }
        }
        anything_to_receive
    }
    fn start_task(&mut self, task:HT) {
        let threads = task.max_threads();
        //dbg!(task.clone(),self.tasks_in_flight);
        for i in 0..threads {
            self.tasks_in_flight += 1;
            if self.idle_threads > 0 {
                self.idle_threads -= 1;
            }
            match self.task_counter.get_mut(&task) {
                Some(counter) => {*counter += 1;},
                None => {self.task_counter.insert(task.clone(), 1);}
            }
            self.send.send(SchedulerTask::Task{tsk:task.clone(), thread_number:i, number_of_threads_on_task:threads}).expect("couldn't send task for some reason");
        }
        //dbg!(self.tasks_in_flight);
    }
    fn advance_all_sequences(&mut self) -> bool {
        let mut advanced_a_sequence = false;
        let mut seq_starts = Vec::with_capacity(2);
        let mut task_starts = Vec::with_capacity(self.current_tasks.tasks.len());
        for seq in &mut self.current_tasks.tasks {
            match seq.get_state() {
                SequenceState::Started => match seq.current_task() {
                    SequencedTask::StartSequence(id) => {seq_starts.push(id); seq.advance_sequence(); advanced_a_sequence = true;},
                    SequencedTask::StartTask(tsk) => {task_starts.push(tsk); seq.advance_sequence(); advanced_a_sequence = true;}
                    SequencedTask::WaitFor(tsk) => {
                        if !self.current_tasks.must_be_finished_before_next.contains(&tsk) {
                            self.current_tasks.must_be_finished_before_next.push(tsk.clone());
                        }
                        match self.task_counter.get(&tsk) {
                            Some(counter) => if *counter == 0 {seq.advance_sequence(); advanced_a_sequence = true;}
                            None => panic!("waiting for a task end before it started... THE HORROR !")
                        }
                    }
                    
                    
                },
                SequenceState::Finished | SequenceState::NotStarted => (),
            }
        }
        
        for start in seq_starts {
            if self.current_tasks.tasks[start].get_state() == SequenceState::NotStarted {
                self.current_tasks.tasks[start].start_sequence();
            }
            else {
                panic!("STARTED AN ALREADY STARTED OR FINISHED TASKKKK !!!!!");
            }
        }
        for start in task_starts {
            self.start_task(start);
        }
        advanced_a_sequence
    }
    pub fn end_threads(mut self) {
        for i in 0..self.number_of_threads {
            self.send.send(SchedulerTask::Stop).expect("couldn't send task for some reason");
        }
    }
}

fn task_thread<HT:HordeTask>(task_rcv:Receiver<SchedulerTask<HT>>, stop_send:Sender<HT>, mut data:HT::HTD) {
    loop {
        match task_rcv.recv() {
            Ok(sc_task) => match sc_task {
                SchedulerTask::Stop => break,
                SchedulerTask::Task{tsk, thread_number, number_of_threads_on_task} => {data.do_task(tsk.clone(), thread_number, number_of_threads_on_task); stop_send.send(tsk).expect("couldn't send stop womp womp"); }
            }
            Err(error) => panic!("grosse erreur dans thread de travail {}", error)
        }
    }
}

/// Any given type used in a HordeTask's handler must implement this trait in order to be used to process tasks
/// 
/// the TID associated type is short for "Task ID", the procedural macros assume that type is `usize`, but it can be any type for a manual implementation of the whole stack
/// 
/// to better understand what this trait is for, here's an example :
/// In most game engines, the rendering engine will have multiple tasks to perform in a given tick, the most important one may be to render the final image and send it to the display, but it may need to prepare data, empty buffers or prepare the next image in seperate tasks that should be done at different times in a given tick
/// by implementing this trait, a given rendering engine can have data preparation as task ID = 0, then rendering as task ID = 1, and so on
/// at runtime, the task sequences will make the right task correspond to the right type and task ID, and use IndividualTask::do_task to execute that task ID on that type.
/// 
/// The number of threads and "thread number" are also passed to do_task in order to be able to divide work between all threads that are given a specific task, thread numbers are in the 0..number_of_threads range, and are specific to each task
pub trait IndividualTask {
    type TD;
    type TID;
    fn do_task(&mut self, task_id:Self::TID, thread_number:usize, number_of_threads:usize);
}